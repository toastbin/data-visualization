# 数据可视化
## SVG（声明式绘图系统）
弥补了DOM元素绘制曲线麻烦的问题，但是在输出图形前仍旧需要经过引擎解析、布局计算和渲染树生成。而且，一个 SVG 元素只表示一种基本图形，如果展示的数据很复杂，生成图形的 SVG 元素就会很多。这样一来，大量的 SVG 元素不仅会占用很多内存空间，还会增加引擎、布局计算和渲染树生成的开销，降低性能，减慢渲染速度。这也就注定了 SVG 只适合应用于元素较少的简单可视化场景。

## canvas 2d （指令式绘图系统）
通过画布进行绘制，做一些交互事件比较麻烦。

## WebGL
使用复杂，功能强大，大批量绘制，超高性能，3D。

## 使用canvas

* canvas和画布上下文

````
<body>
  <canvas width="512" height="512"></canvas>
</body>
````
canvas元素的**width**和**height**是画布宽高而非**css**样式的宽高。

如果不设置CSS样式的宽高默认和canvas元素的宽高相等。

如果设置CSS样式宽高为256px，那么实际的画布宽高就是样式宽高的两倍了。


* canvas 坐标系

和浏览器相似，左上角为坐标原点，x、y轴分别向右向下。

* 绘制几何图形
	1. 获取 Canvas 对象，通过 getContext(‘2d’) 得到 2D 上下文
	2. 设置绘图状态，比如填充颜色 fillStyle，平移变换 translate 等等
	3. 调用 beginPath 指令开始绘制图形
	4. 调用绘图指令，比如 rect，表示绘制矩形
	5. 调用 fill 指令，将绘制内容真正输出到画布上

 